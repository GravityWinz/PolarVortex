import { ArrowBack, ArrowDownward, ArrowForward, ArrowUpward, Clear, Home, Refresh, Send, Stop } from "@mui/icons-material"; import { Box, Button, Chip, Divider, FormControl, Grid, IconButton, InputAdornment, InputLabel, LinearProgress, MenuItem, Pagination, Paper, Select, Stack, TextField, Tooltip, Typography } from "@mui/material"; import React, { useEffect, useRef, useState } from "react"; import logoImage from "../assets/PolarVortexLogo_small.png"; import { clearCommandLog, connectPlotter, disconnectPlotter, getAvailablePorts, getCommandLog, getConnectionStatus, getDefaultPlotter, getJobProgress, resolveApiBaseUrl, resolveWsBaseUrl, runProjectGcode, sendGcodeCommand, stopPlotter, togglePausePlotter, getProjects, getProjectGcodeFiles } from "../services/apiService"; const BASE_URL = resolveApiBaseUrl(); const WS_URL = resolveWsBaseUrl(); export default function ControlPanel({ currentProject }) { const [ports, setPorts] = useState([]); const [selectedPort, setSelectedPort] = useState(""); const [baudRate, setBaudRate] = useState(9600); const [connected, setConnected] = useState(false); const [connectionStatus, setConnectionStatus] = useState(null); const [commandLog, setCommandLog] = useState([]); const [loading, setLoading] = useState(false); const [commandInput, setCommandInput] = useState(""); const [motionMode, setMotionMode] = useState("relative"); const [penState, setPenState] = useState("up"); const [penUpCommand, setPenUpCommand] = useState("M280 P0 S110"); const [penDownCommand, setPenDownCommand] = useState("M280 P0 S130"); const [logPage, setLogPage] = useState(1); const LOG_PAGE_SIZE = 25; const [expandedEntries, setExpandedEntries] = useState(new Set()); const [selectedProject, setSelectedProject] = useState(null); const [selectedProjectGcode, setSelectedProjectGcode] = useState(""); const [gcodeRunning, setGcodeRunning] = useState(false); const [gcodePaused, setGcodePaused] = useState(false); const [gcodeProgress, setGcodeProgress] = useState({ jobId: null, linesSent: 0, linesTotal: 0, progress: 0, status: null }); const logContainerRef = useRef(null); const wsRef = useRef(null); const processedMessagesRef = useRef(new Set()); const progressPollIntervalRef = useRef(null); const [projects, setProjects] = useState([]); const [projectGcodeFiles, setProjectGcodeFiles] = useState([]); const baudRates = [9600, 19200, 38400, 57600, 115200, 250000]; useEffect(() => { loadPorts(); checkConnectionStatus(); loadCommandLog(); loadDefaultPlotterPenCommands(); fetchProjects(); }, []); useEffect(() => { if (selectedProject) { fetchProjectGcodeFiles(selectedProject); } }, [selectedProject]); useEffect(() => { const totalPages = Math.max(1, Math.ceil(commandLog.length / LOG_PAGE_SIZE)); setLogPage(totalPages); }, [commandLog]); useEffect(() => { if (!wsRef.current || wsRef.current.readyState === WebSocket.CLOSED) { connectWebSocket(); } return () => { if (wsRef.current) { wsRef.current.close(); wsRef.current = null; } }; }, []); const connectWebSocket = () => { if (wsRef.current && wsRef.current.readyState !== WebSocket.CLOSED) { return; } try { const ws = new WebSocket(`${WS_URL}/ws`); ws.onopen = () => { console.log("WebSocket connected"); }; ws.onmessage = (event) => { try { const data = JSON.parse(event.data); if (data.type === "gcode_response") { const messageKey = `${data.timestamp}-${data.command}-${data.response}`; if (processedMessagesRef.current.has(messageKey)) { return; } processedMessagesRef.current.add(messageKey); if (processedMessagesRef.current.size > 1000) { const keysArray = Array.from(processedMessagesRef.current); processedMessagesRef.current = new Set(keysArray.slice(-1000)); } setCommandLog((prev) => { const exists = prev.some((entry) => entry.command === data.command && entry.timestamp === data.timestamp && entry.response === data.response); if (exists) { return prev; } return [...prev, { timestamp: data.timestamp, command: data.command, response: data.response }]; }); scrollToBottom(); } } catch (err) { console.error("Error parsing WebSocket message:", err); } }; ws.onerror = (error) => { console.error("WebSocket error:", error); }; ws.onclose = () => { console.log("WebSocket disconnected"); wsRef.current = null; setTimeout(() => { if (wsRef.current === null) { connectWebSocket(); } }, 5000); }; wsRef.current = ws; } catch (err) { console.error("Failed to connect WebSocket:", err); wsRef.current = null; } }; const loadPorts = async () => { try { const result = await getAvailablePorts(); if (result.ports) { setPorts(result.ports); if (result.ports.length > 0 && !selectedPort) { setSelectedPort(result.ports[0].device); } } } catch (err) { console.error("Error loading ports:", err); } }; const checkConnectionStatus = async () => { try { const status = await getConnectionStatus(); setConnected(status.connected || false); setConnectionStatus(status); if (status.connected && status.port) { setSelectedPort(status.port); setBaudRate(status.baud_rate || 9600); } } catch (err) { console.error("Error checking connection status:", err); } }; const loadCommandLog = async () => { try { const result = await getCommandLog(); if (result.log) { result.log.forEach((entry) => { const messageKey = `${entry.timestamp}-${entry.command}-${entry.response}`; processedMessagesRef.current.add(messageKey); }); setCommandLog(result.log); scrollToBottom(true); } } catch (err) { console.error("Error loading command log:", err); } }; const isNearBottom = () => { const el = logContainerRef.current; if (!el) return false; const distance = el.scrollHeight - el.clientHeight - el.scrollTop; return distance < 80; }; const scrollToBottom = (force = false) => { setTimeout(() => { const el = logContainerRef.current; if (!el) return; if (force || isNearBottom()) { el.scrollTop = el.scrollHeight; } }, 100); }; const handleConnect = async () => { if (!selectedPort) { alert("Please select a port"); return; } setLoading(true); try { const result = await connectPlotter(selectedPort, baudRate); if (result.success) { setConnected(true); setConnectionStatus({ connected: true, port: selectedPort, baud_rate: baudRate }); const startupResults = result.startup_gcode?.results || []; if (startupResults.length) { const entries = startupResults.map((item) => ({ timestamp: item.timestamp || new Date().toISOString(), command: item.command || "(on_connect)", response: item.response || (item.error ? `error: ${item.error}` : "") })); setCommandLog((prev) => { const combined = [...prev]; entries.forEach((entry) => { const key = `${entry.timestamp}-${entry.command}-${entry.response}`; const exists = combined.some((e) => e.command === entry.command && e.timestamp === entry.timestamp && e.response === entry.response); if (!exists) { combined.push(entry); } processedMessagesRef.current.add(key); }); if (processedMessagesRef.current.size > 1000) { const keysArray = Array.from(processedMessagesRef.current); processedMessagesRef.current = new Set(keysArray.slice(-1000)); } return combined; }); } await loadCommandLog(); } else { alert(`Connection failed: ${result.error || "Unknown error"}`); } } catch (err) { alert(`Connection error: ${err.message}`); } finally { setLoading(false); } }; const handleDisconnect = async () => { setLoading(true); try { const result = await disconnectPlotter(); if (result.success) { setConnected(false); setConnectionStatus(null); } else { alert(`Disconnect failed: ${result.error || "Unknown error"}`); } } catch (err) { alert(`Disconnect error: ${err.message}`); } finally { setLoading(false); } }; const handleClearLog = async () => { try { await clearCommandLog(); setCommandLog([]); } catch (err) { console.error("Error clearing log:", err); } }; const sendCommand = async (gcode) => { if (!connected) { alert("Please connect to plotter first"); return; } try { const result = await sendGcodeCommand(gcode); if (result?.timestamp) { const entry = { timestamp: result.timestamp, command: result.command || gcode, response: result.response || "" }; const messageKey = `${entry.timestamp}-${entry.command}-${entry.response}`; setCommandLog((prev) => { const exists = prev.some((e) => e.command === entry.command && e.timestamp === entry.timestamp && e.response === entry.response); if (exists) return prev; return [...prev, entry]; }); processedMessagesRef.current.add(messageKey); if (processedMessagesRef.current.size > 1000) { const keysArray = Array.from(processedMessagesRef.current); processedMessagesRef.current = new Set(keysArray.slice(-1000)); } } } catch (err) { alert(`Command error: ${err.message}`); } }; const handleSendCommand = async () => { if (!commandInput.trim()) { return; } const command = commandInput.trim(); setCommandInput(""); await sendCommand(command); }; const handleRunProjectGcode = async () => { if (!selectedProject) { alert("Select a project first"); return; } if (!selectedProjectGcode) { alert("Select a G-code file to send"); return; } if (!connected) { alert("Please connect to plotter first"); return; } try { setGcodeRunning(true); setGcodeProgress({ jobId: null, linesSent: 0, linesTotal: 0, progress: 0, status: null }); const result = await runProjectGcode(selectedProject, selectedProjectGcode); if (result.job_id) { setGcodeProgress({ jobId: result.job_id, linesSent: 0, linesTotal: result.lines_total || 0, progress: 0, status: result.status || "running" }); startProgressPolling(result.job_id); } else { setGcodeRunning(false); setGcodeProgress({ jobId: null, linesSent: 0, linesTotal: 0, progress: 0, status: null }); alert("G-code job started but no job ID was returned. Unable to track progress."); } } catch (err) { alert(`G-code run error: ${err.message}`); setGcodeRunning(false); setGcodeProgress({ jobId: null, linesSent: 0, linesTotal: 0, progress: 0, status: null }); } }; const startProgressPolling = (jobId) => { if (progressPollIntervalRef.current) { clearInterval(progressPollIntervalRef.current); } progressPollIntervalRef.current = setInterval(async () => { try { const progress = await getJobProgress(jobId); setGcodeProgress({ jobId: progress.job_id, linesSent: progress.lines_sent || 0, linesTotal: progress.lines_total || 0, progress: progress.progress || 0, status: progress.status || "unknown" }); if (["completed", "failed", "canceled"].includes(progress.status)) { stopProgressPolling(); setGcodeRunning(false); } else if (progress.status === "paused") { setGcodePaused(true); } else if (progress.status === "running") { setGcodePaused(false); } } catch (err) { console.error("Error polling job progress:", err); } }, 500); }; const stopProgressPolling = () => { if (progressPollIntervalRef.current) { clearInterval(progressPollIntervalRef.current); progressPollIntervalRef.current = null; } }; useEffect(() => { return () => { stopProgressPolling(); } }, []); const handleTogglePause = async () => { try { const res = await togglePausePlotter(); setGcodePaused(res.paused); } catch (err) { alert(`Pause error: ${err.message}`); } }; const handleCommandInputKeyPress = (e) => { if (e.key === "Enter") { handleSendCommand(); } }; return (<Box sx={{ p: 2, bgcolor: "background.default", display: "flex", flexDirection: "column", height: "100%" }}><Grid container spacing={2}><Grid item xs={12}><Paper sx={{ p: 2 }}><Typography variant="h6">Control Panel</Typography><Divider /><Stack direction="row" spacing={1} alignItems="center"><IconButton onClick={() => { handleClearLog(); }}><Clear /></IconButton><Tooltip title="Refresh connection status"><IconButton onClick={() => { checkConnectionStatus(); }}><Refresh /></IconButton></Tooltip><Tooltip title="Connect to plotter"><IconButton color={connected ? "success" : "default"} onClick={() => { handleConnect(); }}><Send /></IconButton></Tooltip><Tooltip title="Disconnect from plotter"><IconButton color={!connected ? "disabled" : "error"} onClick={() => { handleDisconnect(); }}><Stop /></IconButton></Tooltip></Stack></Paper></Grid><Grid item xs={12}><Paper sx={{ p: 2 }}><Typography variant="h6">Motion Control</Typography><Divider /><Stack direction="row" spacing={1} alignItems="center"><Button onClick={() => { setMotionMode("absolute"); }} color={motionMode === "absolute" ? "primary" : "default"}>Absolute</Button><Button onClick={() => { setMotionMode("relative"); }} color={motionMode === "relative" ? "primary" : "default"}>Relative</Button></Stack><Stack direction="row" spacing={1} alignItems="center"><Button onClick={() => { setPenState("up"); }} color={penState === "up" ? "primary" : "default"}>Pen Up</Button><Button onClick={() => { setPenState("down"); }} color={penState === "down" ? "primary" : "default"}>Pen Down</Button></Stack><FormControl fullWidth><InputLabel htmlFor="command-input">G-code Command</InputLabel><TextField id="command-input" value={commandInput} onChange={(e) => { setCommandInput(e.target.value); }} onKeyPress={handleCommandInputKeyPress} InputProps={{ endAdornment: (<InputAdornment position="end"><IconButton onClick={handleSendCommand}><Send /></IconButton></InputAdornment>), }} /></FormControl></Paper></Grid><Grid item xs={12}><Paper sx={{ p: 2 }}><Typography variant="h6">Project Management</Typography><Divider /><Stack direction="row" spacing={1} alignItems="center"><Button onClick={() => { setSelectedProject(null); fetchProjects(); }} color={selectedProject ? "default" : "primary"}>Refresh Projects</Button><FormControl fullWidth><InputLabel id="project-select-label">Select Project</InputLabel><Select labelId="project-select-label" id="project-select" value={selectedProject} onChange={(e) => { setSelectedProject(e.target.value); }}><MenuItem value=""><em>None</em></MenuItem>{projects.map((project) => (<MenuItem key={project.id} value={project.id}>{project.name}</MenuItem>))}</Select></FormControl><FormControl fullWidth><InputLabel id="gcode-file-select-label">Select G-code File</InputLabel><Select labelId="gcode-file-select-label" id="gcode-file-select" value={selectedProjectGcode} onChange={(e) => { setSelectedProjectGcode(e.target.value); }}><MenuItem value=""><em>None</em></MenuItem>{projectGcodeFiles.map((file) => (<MenuItem key={file} value={file}>{file}</MenuItem>))}</Select></FormControl><Button onClick={handleRunProjectGcode} disabled={!selectedProject || !selectedProjectGcode || !connected} color="primary">Run G-code</Button></Stack></Paper></Grid><Grid item xs={12}><Paper sx={{ p: 2 }}><Typography variant="h6">Command Log</Typography><Divider /><Box sx={{ overflowY: "scroll", height: 300, mt: 1 }} ref={logContainerRef}><Stack spacing={1}>{commandLog.map((entry, index) => (<Chip key={index} label={`${entry.timestamp} - ${entry.command} - ${entry.response}`} color="primary" />))}</Stack></Box><Pagination count={Math.ceil(commandLog.length / LOG_PAGE_SIZE)} page={logPage} onChange={(e, value) => { setLogPage(value); }} /></Paper></Grid></Grid></Box>); }